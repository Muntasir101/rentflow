{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///E:/Projects/rentManagement/lib/db.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\n\r\nexport const prisma =\r\n    globalForPrisma.prisma ||\r\n    new PrismaClient({\r\n        log: process.env.NODE_ENV === 'development' ? ['query'] : [],\r\n    });\r\n\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AAEC,MAAM,SACT,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACb,KAAK,uCAAyC;QAAC;KAAQ,GAAG;AAC9D;AAEJ,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 69, "column": 0}, "map": {"version":3,"sources":["file:///E:/Projects/rentManagement/lib/auth.ts"],"sourcesContent":["import { SignJWT, jwtVerify } from 'jose';\r\nimport { cookies } from 'next/headers';\r\nimport { NextRequest, NextResponse } from 'next/server';\r\n\r\n// Get JWT secret from environment variable (lazy loading)\r\nconst getSecretKey = () => {\r\n    const secret = process.env.JWT_SECRET;\r\n    if (!secret) {\r\n        // During build time, allow missing secret\r\n        if (process.env.NODE_ENV === 'production' && typeof window === 'undefined' && process.env.NEXT_PHASE !== 'phase-production-build') {\r\n            throw new Error('JWT_SECRET must be set in production environment');\r\n        }\r\n        // Fallback for development and build time\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            console.warn('⚠️  JWT_SECRET not set, using default. This is unsafe for production!');\r\n        }\r\n        return 'dev-secret-key-change-in-production';\r\n    }\r\n    return secret;\r\n};\r\n\r\nconst getKey = () => {\r\n    const secretKey = getSecretKey();\r\n    return new TextEncoder().encode(secretKey);\r\n};\r\n\r\nexport async function encrypt(payload: any) {\r\n    const key = getKey();\r\n    return await new SignJWT(payload)\r\n        .setProtectedHeader({ alg: 'HS256' })\r\n        .setIssuedAt()\r\n        .setExpirationTime('24h')\r\n        .sign(key);\r\n}\r\n\r\nexport async function decrypt(input: string): Promise<any> {\r\n    const key = getKey();\r\n    const { payload } = await jwtVerify(input, key, {\r\n        algorithms: ['HS256'],\r\n    });\r\n    return payload;\r\n}\r\n\r\nexport async function getSession() {\r\n    const cookieStore = await cookies();\r\n    const session = cookieStore.get('session')?.value;\r\n    if (!session) return null;\r\n    return await decrypt(session);\r\n}\r\n\r\nexport async function updateSession(request: NextRequest) {\r\n    const session = request.cookies.get('session')?.value;\r\n    if (!session) return;\r\n\r\n    // Refresh the session so it doesn't expire\r\n    const parsed = await decrypt(session);\r\n    parsed.expires = new Date(Date.now() + 24 * 60 * 60 * 1000);\r\n    const res = NextResponse.next();\r\n    res.cookies.set({\r\n        name: 'session',\r\n        value: await encrypt(parsed),\r\n        httpOnly: true,\r\n        expires: parsed.expires,\r\n    });\r\n    return res;\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AACA;AACA;;;;AAEA,0DAA0D;AAC1D,MAAM,eAAe;IACjB,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU;IACrC,IAAI,CAAC,QAAQ;QACT,0CAA0C;QAC1C;;QAGA,0CAA0C;QAC1C,wCAA2C;YACvC,QAAQ,IAAI,CAAC;QACjB;QACA,OAAO;IACX;IACA,OAAO;AACX;AAEA,MAAM,SAAS;IACX,MAAM,YAAY;IAClB,OAAO,IAAI,cAAc,MAAM,CAAC;AACpC;AAEO,eAAe,QAAQ,OAAY;IACtC,MAAM,MAAM;IACZ,OAAO,MAAM,IAAI,kKAAO,CAAC,SACpB,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,WAAW,GACX,iBAAiB,CAAC,OAClB,IAAI,CAAC;AACd;AAEO,eAAe,QAAQ,KAAa;IACvC,MAAM,MAAM;IACZ,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,IAAA,sKAAS,EAAC,OAAO,KAAK;QAC5C,YAAY;YAAC;SAAQ;IACzB;IACA,OAAO;AACX;AAEO,eAAe;IAClB,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,MAAM,UAAU,YAAY,GAAG,CAAC,YAAY;IAC5C,IAAI,CAAC,SAAS,OAAO;IACrB,OAAO,MAAM,QAAQ;AACzB;AAEO,eAAe,cAAc,OAAoB;IACpD,MAAM,UAAU,QAAQ,OAAO,CAAC,GAAG,CAAC,YAAY;IAChD,IAAI,CAAC,SAAS;IAEd,2CAA2C;IAC3C,MAAM,SAAS,MAAM,QAAQ;IAC7B,OAAO,OAAO,GAAG,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK;IACtD,MAAM,MAAM,gJAAY,CAAC,IAAI;IAC7B,IAAI,OAAO,CAAC,GAAG,CAAC;QACZ,MAAM;QACN,OAAO,MAAM,QAAQ;QACrB,UAAU;QACV,SAAS,OAAO,OAAO;IAC3B;IACA,OAAO;AACX"}},
    {"offset": {"line": 145, "column": 0}, "map": {"version":3,"sources":["file:///E:/Projects/rentManagement/lib/api-response.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\r\n\r\n/**\r\n * Standardized API response wrapper\r\n */\r\nexport class ApiResponse {\r\n    /**\r\n     * Success response\r\n     */\r\n    static success<T>(data: T, message?: string, status: number = 200) {\r\n        return NextResponse.json(\r\n            {\r\n                success: true,\r\n                message: message || 'Success',\r\n                data,\r\n            },\r\n            { status }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Error response\r\n     */\r\n    static error(\r\n        message: string,\r\n        status: number = 400,\r\n        details?: any,\r\n        code?: string\r\n    ) {\r\n        return NextResponse.json(\r\n            {\r\n                success: false,\r\n                error: {\r\n                    message,\r\n                    code: code || 'ERROR',\r\n                    ...(details && { details }),\r\n                },\r\n            },\r\n            { status }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Validation error response\r\n     */\r\n    static validationError(errors: Array<{ path: string; message: string }>) {\r\n        return NextResponse.json(\r\n            {\r\n                success: false,\r\n                error: {\r\n                    message: 'Validation failed',\r\n                    code: 'VALIDATION_ERROR',\r\n                    details: errors,\r\n                },\r\n            },\r\n            { status: 400 }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Unauthorized response\r\n     */\r\n    static unauthorized(message: string = 'Unauthorized') {\r\n        return NextResponse.json(\r\n            {\r\n                success: false,\r\n                error: {\r\n                    message,\r\n                    code: 'UNAUTHORIZED',\r\n                },\r\n            },\r\n            { status: 401 }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Forbidden response\r\n     */\r\n    static forbidden(message: string = 'Forbidden: Insufficient permissions') {\r\n        return NextResponse.json(\r\n            {\r\n                success: false,\r\n                error: {\r\n                    message,\r\n                    code: 'FORBIDDEN',\r\n                },\r\n            },\r\n            { status: 403 }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Not found response\r\n     */\r\n    static notFound(resource: string = 'Resource') {\r\n        return NextResponse.json(\r\n            {\r\n                success: false,\r\n                error: {\r\n                    message: `${resource} not found`,\r\n                    code: 'NOT_FOUND',\r\n                },\r\n            },\r\n            { status: 404 }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Internal server error response\r\n     */\r\n    static internalError(message: string = 'Internal server error') {\r\n        return NextResponse.json(\r\n            {\r\n                success: false,\r\n                error: {\r\n                    message,\r\n                    code: 'INTERNAL_ERROR',\r\n                },\r\n            },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Pagination metadata\r\n */\r\nexport interface PaginationMeta {\r\n    page: number;\r\n    limit: number;\r\n    total: number;\r\n    totalPages: number;\r\n    hasNext: boolean;\r\n    hasPrev: boolean;\r\n}\r\n\r\n/**\r\n * Paginated response\r\n */\r\nexport function paginatedResponse<T>(\r\n    data: T[],\r\n    meta: PaginationMeta,\r\n    message?: string\r\n) {\r\n    return NextResponse.json({\r\n        success: true,\r\n        message: message || 'Success',\r\n        data,\r\n        pagination: meta,\r\n    });\r\n}\r\n\r\n/**\r\n * Parse pagination query parameters\r\n */\r\nexport function parsePagination(request: Request) {\r\n    const { searchParams } = new URL(request.url);\r\n    const page = Math.max(1, parseInt(searchParams.get('page') || '1', 10));\r\n    const limit = Math.min(100, Math.max(1, parseInt(searchParams.get('limit') || '10', 10)));\r\n    const skip = (page - 1) * limit;\r\n\r\n    return { page, limit, skip };\r\n}\r\n\r\n/**\r\n * Calculate pagination metadata\r\n */\r\nexport function calculatePaginationMeta(\r\n    total: number,\r\n    page: number,\r\n    limit: number\r\n): PaginationMeta {\r\n    const totalPages = Math.ceil(total / limit);\r\n    return {\r\n        page,\r\n        limit,\r\n        total,\r\n        totalPages,\r\n        hasNext: page < totalPages,\r\n        hasPrev: page > 1,\r\n    };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAKO,MAAM;IACT;;KAEC,GACD,OAAO,QAAW,IAAO,EAAE,OAAgB,EAAE,SAAiB,GAAG,EAAE;QAC/D,OAAO,gJAAY,CAAC,IAAI,CACpB;YACI,SAAS;YACT,SAAS,WAAW;YACpB;QACJ,GACA;YAAE;QAAO;IAEjB;IAEA;;KAEC,GACD,OAAO,MACH,OAAe,EACf,SAAiB,GAAG,EACpB,OAAa,EACb,IAAa,EACf;QACE,OAAO,gJAAY,CAAC,IAAI,CACpB;YACI,SAAS;YACT,OAAO;gBACH;gBACA,MAAM,QAAQ;gBACd,GAAI,WAAW;oBAAE;gBAAQ,CAAC;YAC9B;QACJ,GACA;YAAE;QAAO;IAEjB;IAEA;;KAEC,GACD,OAAO,gBAAgB,MAAgD,EAAE;QACrE,OAAO,gJAAY,CAAC,IAAI,CACpB;YACI,SAAS;YACT,OAAO;gBACH,SAAS;gBACT,MAAM;gBACN,SAAS;YACb;QACJ,GACA;YAAE,QAAQ;QAAI;IAEtB;IAEA;;KAEC,GACD,OAAO,aAAa,UAAkB,cAAc,EAAE;QAClD,OAAO,gJAAY,CAAC,IAAI,CACpB;YACI,SAAS;YACT,OAAO;gBACH;gBACA,MAAM;YACV;QACJ,GACA;YAAE,QAAQ;QAAI;IAEtB;IAEA;;KAEC,GACD,OAAO,UAAU,UAAkB,qCAAqC,EAAE;QACtE,OAAO,gJAAY,CAAC,IAAI,CACpB;YACI,SAAS;YACT,OAAO;gBACH;gBACA,MAAM;YACV;QACJ,GACA;YAAE,QAAQ;QAAI;IAEtB;IAEA;;KAEC,GACD,OAAO,SAAS,WAAmB,UAAU,EAAE;QAC3C,OAAO,gJAAY,CAAC,IAAI,CACpB;YACI,SAAS;YACT,OAAO;gBACH,SAAS,GAAG,SAAS,UAAU,CAAC;gBAChC,MAAM;YACV;QACJ,GACA;YAAE,QAAQ;QAAI;IAEtB;IAEA;;KAEC,GACD,OAAO,cAAc,UAAkB,uBAAuB,EAAE;QAC5D,OAAO,gJAAY,CAAC,IAAI,CACpB;YACI,SAAS;YACT,OAAO;gBACH;gBACA,MAAM;YACV;QACJ,GACA;YAAE,QAAQ;QAAI;IAEtB;AACJ;AAiBO,SAAS,kBACZ,IAAS,EACT,IAAoB,EACpB,OAAgB;IAEhB,OAAO,gJAAY,CAAC,IAAI,CAAC;QACrB,SAAS;QACT,SAAS,WAAW;QACpB;QACA,YAAY;IAChB;AACJ;AAKO,SAAS,gBAAgB,OAAgB;IAC5C,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;IAC5C,MAAM,OAAO,KAAK,GAAG,CAAC,GAAG,SAAS,aAAa,GAAG,CAAC,WAAW,KAAK;IACnE,MAAM,QAAQ,KAAK,GAAG,CAAC,KAAK,KAAK,GAAG,CAAC,GAAG,SAAS,aAAa,GAAG,CAAC,YAAY,MAAM;IACpF,MAAM,OAAO,CAAC,OAAO,CAAC,IAAI;IAE1B,OAAO;QAAE;QAAM;QAAO;IAAK;AAC/B;AAKO,SAAS,wBACZ,KAAa,EACb,IAAY,EACZ,KAAa;IAEb,MAAM,aAAa,KAAK,IAAI,CAAC,QAAQ;IACrC,OAAO;QACH;QACA;QACA;QACA;QACA,SAAS,OAAO;QAChB,SAAS,OAAO;IACpB;AACJ"}},
    {"offset": {"line": 286, "column": 0}, "map": {"version":3,"sources":["file:///E:/Projects/rentManagement/lib/auth-middleware.ts"],"sourcesContent":["import { getSession } from './auth';\r\nimport { NextResponse } from 'next/server';\r\nimport type { NextRequest } from 'next/server';\r\nimport { ApiResponse } from './api-response';\r\n\r\nexport interface AuthenticatedRequest extends NextRequest {\r\n    user?: {\r\n        id: string;\r\n        email: string;\r\n        role: string;\r\n    };\r\n}\r\n\r\n/**\r\n * Require authentication for API routes\r\n * Returns the session user or null if unauthorized\r\n */\r\nexport async function requireAuth(request: NextRequest) {\r\n    const session = await getSession();\r\n    \r\n    if (!session) {\r\n        return {\r\n            error: ApiResponse.unauthorized(),\r\n            user: null,\r\n        };\r\n    }\r\n\r\n    return {\r\n        error: null,\r\n        user: session as { id: string; email: string; role: string },\r\n    };\r\n}\r\n\r\n/**\r\n * Require specific role(s) for API routes\r\n * @param allowedRoles - Array of allowed roles (e.g., ['ADMIN', 'MANAGER'])\r\n */\r\nexport async function requireRole(\r\n    request: NextRequest,\r\n    allowedRoles: string[]\r\n) {\r\n    const authResult = await requireAuth(request);\r\n    \r\n    if (authResult.error) {\r\n        return authResult;\r\n    }\r\n\r\n    const user = authResult.user!;\r\n    \r\n    if (!allowedRoles.includes(user.role)) {\r\n        return {\r\n            error: ApiResponse.forbidden(),\r\n            user: null,\r\n        };\r\n    }\r\n\r\n    return authResult;\r\n}\r\n\r\n/**\r\n * Role hierarchy check\r\n * Higher roles have more permissions\r\n */\r\nexport const ROLE_HIERARCHY: Record<string, number> = {\r\n    ADMIN: 4,\r\n    MANAGER: 3,\r\n    STAFF: 2,\r\n    TENANT: 1,\r\n};\r\n\r\nexport function hasRolePermission(userRole: string, requiredRole: string): boolean {\r\n    const userLevel = ROLE_HIERARCHY[userRole] || 0;\r\n    const requiredLevel = ROLE_HIERARCHY[requiredRole] || 0;\r\n    return userLevel >= requiredLevel;\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AAGA;;;AAcO,eAAe,YAAY,OAAoB;IAClD,MAAM,UAAU,MAAM,IAAA,2HAAU;IAEhC,IAAI,CAAC,SAAS;QACV,OAAO;YACH,OAAO,uIAAW,CAAC,YAAY;YAC/B,MAAM;QACV;IACJ;IAEA,OAAO;QACH,OAAO;QACP,MAAM;IACV;AACJ;AAMO,eAAe,YAClB,OAAoB,EACpB,YAAsB;IAEtB,MAAM,aAAa,MAAM,YAAY;IAErC,IAAI,WAAW,KAAK,EAAE;QAClB,OAAO;IACX;IAEA,MAAM,OAAO,WAAW,IAAI;IAE5B,IAAI,CAAC,aAAa,QAAQ,CAAC,KAAK,IAAI,GAAG;QACnC,OAAO;YACH,OAAO,uIAAW,CAAC,SAAS;YAC5B,MAAM;QACV;IACJ;IAEA,OAAO;AACX;AAMO,MAAM,iBAAyC;IAClD,OAAO;IACP,SAAS;IACT,OAAO;IACP,QAAQ;AACZ;AAEO,SAAS,kBAAkB,QAAgB,EAAE,YAAoB;IACpE,MAAM,YAAY,cAAc,CAAC,SAAS,IAAI;IAC9C,MAAM,gBAAgB,cAAc,CAAC,aAAa,IAAI;IACtD,OAAO,aAAa;AACxB"}},
    {"offset": {"line": 342, "column": 0}, "map": {"version":3,"sources":["file:///E:/Projects/rentManagement/lib/logger.ts"],"sourcesContent":["/**\r\n * Simple logger utility for consistent error logging\r\n */\r\n\r\ntype LogLevel = 'info' | 'warn' | 'error' | 'debug';\r\n\r\ninterface LogEntry {\r\n    level: LogLevel;\r\n    message: string;\r\n    timestamp: string;\r\n    context?: Record<string, any>;\r\n    error?: Error;\r\n}\r\n\r\nclass Logger {\r\n    private formatMessage(entry: LogEntry): string {\r\n        const { level, message, timestamp, context, error } = entry;\r\n        let logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;\r\n\r\n        if (context && Object.keys(context).length > 0) {\r\n            logMessage += ` | Context: ${JSON.stringify(context)}`;\r\n        }\r\n\r\n        if (error) {\r\n            logMessage += ` | Error: ${error.message}`;\r\n            if (error.stack) {\r\n                logMessage += ` | Stack: ${error.stack}`;\r\n            }\r\n        }\r\n\r\n        return logMessage;\r\n    }\r\n\r\n    private log(level: LogLevel, message: string, context?: Record<string, any>, error?: Error) {\r\n        const entry: LogEntry = {\r\n            level,\r\n            message,\r\n            timestamp: new Date().toISOString(),\r\n            context,\r\n            error,\r\n        };\r\n\r\n        const formattedMessage = this.formatMessage(entry);\r\n\r\n        switch (level) {\r\n            case 'error':\r\n                console.error(formattedMessage);\r\n                // In production, you might want to send to error tracking service\r\n                break;\r\n            case 'warn':\r\n                console.warn(formattedMessage);\r\n                break;\r\n            case 'debug':\r\n                if (process.env.NODE_ENV === 'development') {\r\n                    console.debug(formattedMessage);\r\n                }\r\n                break;\r\n            default:\r\n                console.log(formattedMessage);\r\n        }\r\n    }\r\n\r\n    info(message: string, context?: Record<string, any>) {\r\n        this.log('info', message, context);\r\n    }\r\n\r\n    warn(message: string, context?: Record<string, any>) {\r\n        this.log('warn', message, context);\r\n    }\r\n\r\n    error(message: string, error?: Error, context?: Record<string, any>) {\r\n        this.log('error', message, context, error);\r\n    }\r\n\r\n    debug(message: string, context?: Record<string, any>) {\r\n        this.log('debug', message, context);\r\n    }\r\n}\r\n\r\nexport const logger = new Logger();\r\n\r\n"],"names":[],"mappings":"AAAA;;CAEC;;;;AAYD,MAAM;IACM,cAAc,KAAe,EAAU;QAC3C,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG;QACtD,IAAI,aAAa,CAAC,CAAC,EAAE,UAAU,GAAG,EAAE,MAAM,WAAW,GAAG,EAAE,EAAE,SAAS;QAErE,IAAI,WAAW,OAAO,IAAI,CAAC,SAAS,MAAM,GAAG,GAAG;YAC5C,cAAc,CAAC,YAAY,EAAE,KAAK,SAAS,CAAC,UAAU;QAC1D;QAEA,IAAI,OAAO;YACP,cAAc,CAAC,UAAU,EAAE,MAAM,OAAO,EAAE;YAC1C,IAAI,MAAM,KAAK,EAAE;gBACb,cAAc,CAAC,UAAU,EAAE,MAAM,KAAK,EAAE;YAC5C;QACJ;QAEA,OAAO;IACX;IAEQ,IAAI,KAAe,EAAE,OAAe,EAAE,OAA6B,EAAE,KAAa,EAAE;QACxF,MAAM,QAAkB;YACpB;YACA;YACA,WAAW,IAAI,OAAO,WAAW;YACjC;YACA;QACJ;QAEA,MAAM,mBAAmB,IAAI,CAAC,aAAa,CAAC;QAE5C,OAAQ;YACJ,KAAK;gBACD,QAAQ,KAAK,CAAC;gBAEd;YACJ,KAAK;gBACD,QAAQ,IAAI,CAAC;gBACb;YACJ,KAAK;gBACD,wCAA4C;oBACxC,QAAQ,KAAK,CAAC;gBAClB;gBACA;YACJ;gBACI,QAAQ,GAAG,CAAC;QACpB;IACJ;IAEA,KAAK,OAAe,EAAE,OAA6B,EAAE;QACjD,IAAI,CAAC,GAAG,CAAC,QAAQ,SAAS;IAC9B;IAEA,KAAK,OAAe,EAAE,OAA6B,EAAE;QACjD,IAAI,CAAC,GAAG,CAAC,QAAQ,SAAS;IAC9B;IAEA,MAAM,OAAe,EAAE,KAAa,EAAE,OAA6B,EAAE;QACjE,IAAI,CAAC,GAAG,CAAC,SAAS,SAAS,SAAS;IACxC;IAEA,MAAM,OAAe,EAAE,OAA6B,EAAE;QAClD,IAAI,CAAC,GAAG,CAAC,SAAS,SAAS;IAC/B;AACJ;AAEO,MAAM,SAAS,IAAI"}},
    {"offset": {"line": 406, "column": 0}, "map": {"version":3,"sources":["file:///E:/Projects/rentManagement/app/api/users/route.ts"],"sourcesContent":["import { prisma } from '@/lib/db';\r\nimport { requireAuth, requireRole } from '@/lib/auth-middleware';\r\nimport { ApiResponse } from '@/lib/api-response';\r\nimport { logger } from '@/lib/logger';\r\nimport type { NextRequest } from 'next/server';\r\n\r\nexport async function GET(request: NextRequest) {\r\n    try {\r\n        // Require authentication and ADMIN/MANAGER/STAFF role\r\n        const authResult = await requireRole(request, ['ADMIN', 'MANAGER', 'STAFF']);\r\n        if (authResult.error) {\r\n            return authResult.error;\r\n        }\r\n\r\n        const { searchParams } = new URL(request.url);\r\n        const role = searchParams.get('role'); // Optional filter by role\r\n\r\n        const whereClause: any = {\r\n            active: true,\r\n        };\r\n\r\n        if (role) {\r\n            whereClause.role = role;\r\n        } else {\r\n            // Default: return staff, managers, and admins (for assignment)\r\n            whereClause.role = {\r\n                in: ['ADMIN', 'MANAGER', 'STAFF'],\r\n            };\r\n        }\r\n\r\n        const users = await prisma.user.findMany({\r\n            where: whereClause,\r\n            select: {\r\n                id: true,\r\n                name: true,\r\n                email: true,\r\n                role: true,\r\n            },\r\n            orderBy: {\r\n                name: 'asc',\r\n            },\r\n        });\r\n\r\n        return ApiResponse.success(users);\r\n    } catch (error: any) {\r\n        logger.error('Failed to fetch users', error, { endpoint: '/api/users' });\r\n        return ApiResponse.internalError('Failed to fetch users');\r\n    }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAGO,eAAe,IAAI,OAAoB;IAC1C,IAAI;QACA,sDAAsD;QACtD,MAAM,aAAa,MAAM,IAAA,0IAAW,EAAC,SAAS;YAAC;YAAS;YAAW;SAAQ;QAC3E,IAAI,WAAW,KAAK,EAAE;YAClB,OAAO,WAAW,KAAK;QAC3B;QAEA,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,OAAO,aAAa,GAAG,CAAC,SAAS,0BAA0B;QAEjE,MAAM,cAAmB;YACrB,QAAQ;QACZ;QAEA,IAAI,MAAM;YACN,YAAY,IAAI,GAAG;QACvB,OAAO;YACH,+DAA+D;YAC/D,YAAY,IAAI,GAAG;gBACf,IAAI;oBAAC;oBAAS;oBAAW;iBAAQ;YACrC;QACJ;QAEA,MAAM,QAAQ,MAAM,qHAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;YACrC,OAAO;YACP,QAAQ;gBACJ,IAAI;gBACJ,MAAM;gBACN,OAAO;gBACP,MAAM;YACV;YACA,SAAS;gBACL,MAAM;YACV;QACJ;QAEA,OAAO,uIAAW,CAAC,OAAO,CAAC;IAC/B,EAAE,OAAO,OAAY;QACjB,yHAAM,CAAC,KAAK,CAAC,yBAAyB,OAAO;YAAE,UAAU;QAAa;QACtE,OAAO,uIAAW,CAAC,aAAa,CAAC;IACrC;AACJ"}}]
}