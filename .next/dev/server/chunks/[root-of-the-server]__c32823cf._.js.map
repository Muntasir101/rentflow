{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///E:/Projects/rentManagement/lib/db.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\n\r\nexport const prisma =\r\n    globalForPrisma.prisma ||\r\n    new PrismaClient({\r\n        log: process.env.NODE_ENV === 'development' ? ['query'] : [],\r\n    });\r\n\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AAEC,MAAM,SACT,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACb,KAAK,uCAAyC;QAAC;KAAQ,GAAG;AAC9D;AAEJ,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 69, "column": 0}, "map": {"version":3,"sources":["file:///E:/Projects/rentManagement/lib/auth.ts"],"sourcesContent":["import { SignJWT, jwtVerify } from 'jose';\r\nimport { cookies } from 'next/headers';\r\nimport { NextRequest, NextResponse } from 'next/server';\r\n\r\n// Get JWT secret from environment variable (lazy loading)\r\nconst getSecretKey = () => {\r\n    const secret = process.env.JWT_SECRET;\r\n    if (!secret) {\r\n        // During build time, allow missing secret\r\n        if (process.env.NODE_ENV === 'production' && typeof window === 'undefined' && process.env.NEXT_PHASE !== 'phase-production-build') {\r\n            throw new Error('JWT_SECRET must be set in production environment');\r\n        }\r\n        // Fallback for development and build time\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            console.warn('⚠️  JWT_SECRET not set, using default. This is unsafe for production!');\r\n        }\r\n        return 'dev-secret-key-change-in-production';\r\n    }\r\n    return secret;\r\n};\r\n\r\nconst getKey = () => {\r\n    const secretKey = getSecretKey();\r\n    return new TextEncoder().encode(secretKey);\r\n};\r\n\r\nexport async function encrypt(payload: any) {\r\n    const key = getKey();\r\n    return await new SignJWT(payload)\r\n        .setProtectedHeader({ alg: 'HS256' })\r\n        .setIssuedAt()\r\n        .setExpirationTime('24h')\r\n        .sign(key);\r\n}\r\n\r\nexport async function decrypt(input: string): Promise<any> {\r\n    const key = getKey();\r\n    const { payload } = await jwtVerify(input, key, {\r\n        algorithms: ['HS256'],\r\n    });\r\n    return payload;\r\n}\r\n\r\nexport async function getSession() {\r\n    const cookieStore = await cookies();\r\n    const session = cookieStore.get('session')?.value;\r\n    if (!session) return null;\r\n    return await decrypt(session);\r\n}\r\n\r\nexport async function updateSession(request: NextRequest) {\r\n    const session = request.cookies.get('session')?.value;\r\n    if (!session) return;\r\n\r\n    // Refresh the session so it doesn't expire\r\n    const parsed = await decrypt(session);\r\n    parsed.expires = new Date(Date.now() + 24 * 60 * 60 * 1000);\r\n    const res = NextResponse.next();\r\n    res.cookies.set({\r\n        name: 'session',\r\n        value: await encrypt(parsed),\r\n        httpOnly: true,\r\n        expires: parsed.expires,\r\n    });\r\n    return res;\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AACA;AACA;;;;AAEA,0DAA0D;AAC1D,MAAM,eAAe;IACjB,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU;IACrC,IAAI,CAAC,QAAQ;QACT,0CAA0C;QAC1C;;QAGA,0CAA0C;QAC1C,wCAA2C;YACvC,QAAQ,IAAI,CAAC;QACjB;QACA,OAAO;IACX;IACA,OAAO;AACX;AAEA,MAAM,SAAS;IACX,MAAM,YAAY;IAClB,OAAO,IAAI,cAAc,MAAM,CAAC;AACpC;AAEO,eAAe,QAAQ,OAAY;IACtC,MAAM,MAAM;IACZ,OAAO,MAAM,IAAI,kKAAO,CAAC,SACpB,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,WAAW,GACX,iBAAiB,CAAC,OAClB,IAAI,CAAC;AACd;AAEO,eAAe,QAAQ,KAAa;IACvC,MAAM,MAAM;IACZ,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,IAAA,sKAAS,EAAC,OAAO,KAAK;QAC5C,YAAY;YAAC;SAAQ;IACzB;IACA,OAAO;AACX;AAEO,eAAe;IAClB,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,MAAM,UAAU,YAAY,GAAG,CAAC,YAAY;IAC5C,IAAI,CAAC,SAAS,OAAO;IACrB,OAAO,MAAM,QAAQ;AACzB;AAEO,eAAe,cAAc,OAAoB;IACpD,MAAM,UAAU,QAAQ,OAAO,CAAC,GAAG,CAAC,YAAY;IAChD,IAAI,CAAC,SAAS;IAEd,2CAA2C;IAC3C,MAAM,SAAS,MAAM,QAAQ;IAC7B,OAAO,OAAO,GAAG,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK;IACtD,MAAM,MAAM,gJAAY,CAAC,IAAI;IAC7B,IAAI,OAAO,CAAC,GAAG,CAAC;QACZ,MAAM;QACN,OAAO,MAAM,QAAQ;QACrB,UAAU;QACV,SAAS,OAAO,OAAO;IAC3B;IACA,OAAO;AACX"}},
    {"offset": {"line": 145, "column": 0}, "map": {"version":3,"sources":["file:///E:/Projects/rentManagement/lib/api-response.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\r\n\r\n/**\r\n * Standardized API response wrapper\r\n */\r\nexport class ApiResponse {\r\n    /**\r\n     * Success response\r\n     */\r\n    static success<T>(data: T, message?: string, status: number = 200) {\r\n        return NextResponse.json(\r\n            {\r\n                success: true,\r\n                message: message || 'Success',\r\n                data,\r\n            },\r\n            { status }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Error response\r\n     */\r\n    static error(\r\n        message: string,\r\n        status: number = 400,\r\n        details?: any,\r\n        code?: string\r\n    ) {\r\n        return NextResponse.json(\r\n            {\r\n                success: false,\r\n                error: {\r\n                    message,\r\n                    code: code || 'ERROR',\r\n                    ...(details && { details }),\r\n                },\r\n            },\r\n            { status }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Validation error response\r\n     */\r\n    static validationError(errors: Array<{ path: string; message: string }>) {\r\n        return NextResponse.json(\r\n            {\r\n                success: false,\r\n                error: {\r\n                    message: 'Validation failed',\r\n                    code: 'VALIDATION_ERROR',\r\n                    details: errors,\r\n                },\r\n            },\r\n            { status: 400 }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Unauthorized response\r\n     */\r\n    static unauthorized(message: string = 'Unauthorized') {\r\n        return NextResponse.json(\r\n            {\r\n                success: false,\r\n                error: {\r\n                    message,\r\n                    code: 'UNAUTHORIZED',\r\n                },\r\n            },\r\n            { status: 401 }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Forbidden response\r\n     */\r\n    static forbidden(message: string = 'Forbidden: Insufficient permissions') {\r\n        return NextResponse.json(\r\n            {\r\n                success: false,\r\n                error: {\r\n                    message,\r\n                    code: 'FORBIDDEN',\r\n                },\r\n            },\r\n            { status: 403 }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Not found response\r\n     */\r\n    static notFound(resource: string = 'Resource') {\r\n        return NextResponse.json(\r\n            {\r\n                success: false,\r\n                error: {\r\n                    message: `${resource} not found`,\r\n                    code: 'NOT_FOUND',\r\n                },\r\n            },\r\n            { status: 404 }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Internal server error response\r\n     */\r\n    static internalError(message: string = 'Internal server error') {\r\n        return NextResponse.json(\r\n            {\r\n                success: false,\r\n                error: {\r\n                    message,\r\n                    code: 'INTERNAL_ERROR',\r\n                },\r\n            },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Pagination metadata\r\n */\r\nexport interface PaginationMeta {\r\n    page: number;\r\n    limit: number;\r\n    total: number;\r\n    totalPages: number;\r\n    hasNext: boolean;\r\n    hasPrev: boolean;\r\n}\r\n\r\n/**\r\n * Paginated response\r\n */\r\nexport function paginatedResponse<T>(\r\n    data: T[],\r\n    meta: PaginationMeta,\r\n    message?: string\r\n) {\r\n    return NextResponse.json({\r\n        success: true,\r\n        message: message || 'Success',\r\n        data,\r\n        pagination: meta,\r\n    });\r\n}\r\n\r\n/**\r\n * Parse pagination query parameters\r\n */\r\nexport function parsePagination(request: Request) {\r\n    const { searchParams } = new URL(request.url);\r\n    const page = Math.max(1, parseInt(searchParams.get('page') || '1', 10));\r\n    const limit = Math.min(100, Math.max(1, parseInt(searchParams.get('limit') || '10', 10)));\r\n    const skip = (page - 1) * limit;\r\n\r\n    return { page, limit, skip };\r\n}\r\n\r\n/**\r\n * Calculate pagination metadata\r\n */\r\nexport function calculatePaginationMeta(\r\n    total: number,\r\n    page: number,\r\n    limit: number\r\n): PaginationMeta {\r\n    const totalPages = Math.ceil(total / limit);\r\n    return {\r\n        page,\r\n        limit,\r\n        total,\r\n        totalPages,\r\n        hasNext: page < totalPages,\r\n        hasPrev: page > 1,\r\n    };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAKO,MAAM;IACT;;KAEC,GACD,OAAO,QAAW,IAAO,EAAE,OAAgB,EAAE,SAAiB,GAAG,EAAE;QAC/D,OAAO,gJAAY,CAAC,IAAI,CACpB;YACI,SAAS;YACT,SAAS,WAAW;YACpB;QACJ,GACA;YAAE;QAAO;IAEjB;IAEA;;KAEC,GACD,OAAO,MACH,OAAe,EACf,SAAiB,GAAG,EACpB,OAAa,EACb,IAAa,EACf;QACE,OAAO,gJAAY,CAAC,IAAI,CACpB;YACI,SAAS;YACT,OAAO;gBACH;gBACA,MAAM,QAAQ;gBACd,GAAI,WAAW;oBAAE;gBAAQ,CAAC;YAC9B;QACJ,GACA;YAAE;QAAO;IAEjB;IAEA;;KAEC,GACD,OAAO,gBAAgB,MAAgD,EAAE;QACrE,OAAO,gJAAY,CAAC,IAAI,CACpB;YACI,SAAS;YACT,OAAO;gBACH,SAAS;gBACT,MAAM;gBACN,SAAS;YACb;QACJ,GACA;YAAE,QAAQ;QAAI;IAEtB;IAEA;;KAEC,GACD,OAAO,aAAa,UAAkB,cAAc,EAAE;QAClD,OAAO,gJAAY,CAAC,IAAI,CACpB;YACI,SAAS;YACT,OAAO;gBACH;gBACA,MAAM;YACV;QACJ,GACA;YAAE,QAAQ;QAAI;IAEtB;IAEA;;KAEC,GACD,OAAO,UAAU,UAAkB,qCAAqC,EAAE;QACtE,OAAO,gJAAY,CAAC,IAAI,CACpB;YACI,SAAS;YACT,OAAO;gBACH;gBACA,MAAM;YACV;QACJ,GACA;YAAE,QAAQ;QAAI;IAEtB;IAEA;;KAEC,GACD,OAAO,SAAS,WAAmB,UAAU,EAAE;QAC3C,OAAO,gJAAY,CAAC,IAAI,CACpB;YACI,SAAS;YACT,OAAO;gBACH,SAAS,GAAG,SAAS,UAAU,CAAC;gBAChC,MAAM;YACV;QACJ,GACA;YAAE,QAAQ;QAAI;IAEtB;IAEA;;KAEC,GACD,OAAO,cAAc,UAAkB,uBAAuB,EAAE;QAC5D,OAAO,gJAAY,CAAC,IAAI,CACpB;YACI,SAAS;YACT,OAAO;gBACH;gBACA,MAAM;YACV;QACJ,GACA;YAAE,QAAQ;QAAI;IAEtB;AACJ;AAiBO,SAAS,kBACZ,IAAS,EACT,IAAoB,EACpB,OAAgB;IAEhB,OAAO,gJAAY,CAAC,IAAI,CAAC;QACrB,SAAS;QACT,SAAS,WAAW;QACpB;QACA,YAAY;IAChB;AACJ;AAKO,SAAS,gBAAgB,OAAgB;IAC5C,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;IAC5C,MAAM,OAAO,KAAK,GAAG,CAAC,GAAG,SAAS,aAAa,GAAG,CAAC,WAAW,KAAK;IACnE,MAAM,QAAQ,KAAK,GAAG,CAAC,KAAK,KAAK,GAAG,CAAC,GAAG,SAAS,aAAa,GAAG,CAAC,YAAY,MAAM;IACpF,MAAM,OAAO,CAAC,OAAO,CAAC,IAAI;IAE1B,OAAO;QAAE;QAAM;QAAO;IAAK;AAC/B;AAKO,SAAS,wBACZ,KAAa,EACb,IAAY,EACZ,KAAa;IAEb,MAAM,aAAa,KAAK,IAAI,CAAC,QAAQ;IACrC,OAAO;QACH;QACA;QACA;QACA;QACA,SAAS,OAAO;QAChB,SAAS,OAAO;IACpB;AACJ"}},
    {"offset": {"line": 286, "column": 0}, "map": {"version":3,"sources":["file:///E:/Projects/rentManagement/lib/auth-middleware.ts"],"sourcesContent":["import { getSession } from './auth';\r\nimport { NextResponse } from 'next/server';\r\nimport type { NextRequest } from 'next/server';\r\nimport { ApiResponse } from './api-response';\r\n\r\nexport interface AuthenticatedRequest extends NextRequest {\r\n    user?: {\r\n        id: string;\r\n        email: string;\r\n        role: string;\r\n    };\r\n}\r\n\r\n/**\r\n * Require authentication for API routes\r\n * Returns the session user or null if unauthorized\r\n */\r\nexport async function requireAuth(request: NextRequest) {\r\n    const session = await getSession();\r\n    \r\n    if (!session) {\r\n        return {\r\n            error: ApiResponse.unauthorized(),\r\n            user: null,\r\n        };\r\n    }\r\n\r\n    return {\r\n        error: null,\r\n        user: session as { id: string; email: string; role: string },\r\n    };\r\n}\r\n\r\n/**\r\n * Require specific role(s) for API routes\r\n * @param allowedRoles - Array of allowed roles (e.g., ['ADMIN', 'MANAGER'])\r\n */\r\nexport async function requireRole(\r\n    request: NextRequest,\r\n    allowedRoles: string[]\r\n) {\r\n    const authResult = await requireAuth(request);\r\n    \r\n    if (authResult.error) {\r\n        return authResult;\r\n    }\r\n\r\n    const user = authResult.user!;\r\n    \r\n    if (!allowedRoles.includes(user.role)) {\r\n        return {\r\n            error: ApiResponse.forbidden(),\r\n            user: null,\r\n        };\r\n    }\r\n\r\n    return authResult;\r\n}\r\n\r\n/**\r\n * Role hierarchy check\r\n * Higher roles have more permissions\r\n */\r\nexport const ROLE_HIERARCHY: Record<string, number> = {\r\n    ADMIN: 4,\r\n    MANAGER: 3,\r\n    STAFF: 2,\r\n    TENANT: 1,\r\n};\r\n\r\nexport function hasRolePermission(userRole: string, requiredRole: string): boolean {\r\n    const userLevel = ROLE_HIERARCHY[userRole] || 0;\r\n    const requiredLevel = ROLE_HIERARCHY[requiredRole] || 0;\r\n    return userLevel >= requiredLevel;\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AAGA;;;AAcO,eAAe,YAAY,OAAoB;IAClD,MAAM,UAAU,MAAM,IAAA,2HAAU;IAEhC,IAAI,CAAC,SAAS;QACV,OAAO;YACH,OAAO,uIAAW,CAAC,YAAY;YAC/B,MAAM;QACV;IACJ;IAEA,OAAO;QACH,OAAO;QACP,MAAM;IACV;AACJ;AAMO,eAAe,YAClB,OAAoB,EACpB,YAAsB;IAEtB,MAAM,aAAa,MAAM,YAAY;IAErC,IAAI,WAAW,KAAK,EAAE;QAClB,OAAO;IACX;IAEA,MAAM,OAAO,WAAW,IAAI;IAE5B,IAAI,CAAC,aAAa,QAAQ,CAAC,KAAK,IAAI,GAAG;QACnC,OAAO;YACH,OAAO,uIAAW,CAAC,SAAS;YAC5B,MAAM;QACV;IACJ;IAEA,OAAO;AACX;AAMO,MAAM,iBAAyC;IAClD,OAAO;IACP,SAAS;IACT,OAAO;IACP,QAAQ;AACZ;AAEO,SAAS,kBAAkB,QAAgB,EAAE,YAAoB;IACpE,MAAM,YAAY,cAAc,CAAC,SAAS,IAAI;IAC9C,MAAM,gBAAgB,cAAc,CAAC,aAAa,IAAI;IACtD,OAAO,aAAa;AACxB"}},
    {"offset": {"line": 342, "column": 0}, "map": {"version":3,"sources":["file:///E:/Projects/rentManagement/lib/logger.ts"],"sourcesContent":["/**\r\n * Simple logger utility for consistent error logging\r\n */\r\n\r\ntype LogLevel = 'info' | 'warn' | 'error' | 'debug';\r\n\r\ninterface LogEntry {\r\n    level: LogLevel;\r\n    message: string;\r\n    timestamp: string;\r\n    context?: Record<string, any>;\r\n    error?: Error;\r\n}\r\n\r\nclass Logger {\r\n    private formatMessage(entry: LogEntry): string {\r\n        const { level, message, timestamp, context, error } = entry;\r\n        let logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;\r\n\r\n        if (context && Object.keys(context).length > 0) {\r\n            logMessage += ` | Context: ${JSON.stringify(context)}`;\r\n        }\r\n\r\n        if (error) {\r\n            logMessage += ` | Error: ${error.message}`;\r\n            if (error.stack) {\r\n                logMessage += ` | Stack: ${error.stack}`;\r\n            }\r\n        }\r\n\r\n        return logMessage;\r\n    }\r\n\r\n    private log(level: LogLevel, message: string, context?: Record<string, any>, error?: Error) {\r\n        const entry: LogEntry = {\r\n            level,\r\n            message,\r\n            timestamp: new Date().toISOString(),\r\n            context,\r\n            error,\r\n        };\r\n\r\n        const formattedMessage = this.formatMessage(entry);\r\n\r\n        switch (level) {\r\n            case 'error':\r\n                console.error(formattedMessage);\r\n                // In production, you might want to send to error tracking service\r\n                break;\r\n            case 'warn':\r\n                console.warn(formattedMessage);\r\n                break;\r\n            case 'debug':\r\n                if (process.env.NODE_ENV === 'development') {\r\n                    console.debug(formattedMessage);\r\n                }\r\n                break;\r\n            default:\r\n                console.log(formattedMessage);\r\n        }\r\n    }\r\n\r\n    info(message: string, context?: Record<string, any>) {\r\n        this.log('info', message, context);\r\n    }\r\n\r\n    warn(message: string, context?: Record<string, any>) {\r\n        this.log('warn', message, context);\r\n    }\r\n\r\n    error(message: string, error?: Error, context?: Record<string, any>) {\r\n        this.log('error', message, context, error);\r\n    }\r\n\r\n    debug(message: string, context?: Record<string, any>) {\r\n        this.log('debug', message, context);\r\n    }\r\n}\r\n\r\nexport const logger = new Logger();\r\n\r\n"],"names":[],"mappings":"AAAA;;CAEC;;;;AAYD,MAAM;IACM,cAAc,KAAe,EAAU;QAC3C,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG;QACtD,IAAI,aAAa,CAAC,CAAC,EAAE,UAAU,GAAG,EAAE,MAAM,WAAW,GAAG,EAAE,EAAE,SAAS;QAErE,IAAI,WAAW,OAAO,IAAI,CAAC,SAAS,MAAM,GAAG,GAAG;YAC5C,cAAc,CAAC,YAAY,EAAE,KAAK,SAAS,CAAC,UAAU;QAC1D;QAEA,IAAI,OAAO;YACP,cAAc,CAAC,UAAU,EAAE,MAAM,OAAO,EAAE;YAC1C,IAAI,MAAM,KAAK,EAAE;gBACb,cAAc,CAAC,UAAU,EAAE,MAAM,KAAK,EAAE;YAC5C;QACJ;QAEA,OAAO;IACX;IAEQ,IAAI,KAAe,EAAE,OAAe,EAAE,OAA6B,EAAE,KAAa,EAAE;QACxF,MAAM,QAAkB;YACpB;YACA;YACA,WAAW,IAAI,OAAO,WAAW;YACjC;YACA;QACJ;QAEA,MAAM,mBAAmB,IAAI,CAAC,aAAa,CAAC;QAE5C,OAAQ;YACJ,KAAK;gBACD,QAAQ,KAAK,CAAC;gBAEd;YACJ,KAAK;gBACD,QAAQ,IAAI,CAAC;gBACb;YACJ,KAAK;gBACD,wCAA4C;oBACxC,QAAQ,KAAK,CAAC;gBAClB;gBACA;YACJ;gBACI,QAAQ,GAAG,CAAC;QACpB;IACJ;IAEA,KAAK,OAAe,EAAE,OAA6B,EAAE;QACjD,IAAI,CAAC,GAAG,CAAC,QAAQ,SAAS;IAC9B;IAEA,KAAK,OAAe,EAAE,OAA6B,EAAE;QACjD,IAAI,CAAC,GAAG,CAAC,QAAQ,SAAS;IAC9B;IAEA,MAAM,OAAe,EAAE,KAAa,EAAE,OAA6B,EAAE;QACjE,IAAI,CAAC,GAAG,CAAC,SAAS,SAAS,SAAS;IACxC;IAEA,MAAM,OAAe,EAAE,OAA6B,EAAE;QAClD,IAAI,CAAC,GAAG,CAAC,SAAS,SAAS;IAC/B;AACJ;AAEO,MAAM,SAAS,IAAI"}},
    {"offset": {"line": 406, "column": 0}, "map": {"version":3,"sources":["file:///E:/Projects/rentManagement/app/api/tenants/%5Bid%5D/route.ts"],"sourcesContent":["import { prisma } from '@/lib/db';\r\nimport { requireAuth, requireRole } from '@/lib/auth-middleware';\r\nimport { ApiResponse } from '@/lib/api-response';\r\nimport { logger } from '@/lib/logger';\r\nimport type { NextRequest } from 'next/server';\r\n\r\nexport async function GET(\r\n    request: NextRequest,\r\n    { params }: { params: Promise<{ id: string }> }\r\n) {\r\n    try {\r\n        // Require authentication\r\n        const authResult = await requireAuth(request);\r\n        if (authResult.error) {\r\n            return authResult.error;\r\n        }\r\n\r\n        const user = authResult.user!;\r\n        const { id } = await params;\r\n\r\n        const tenant = await prisma.tenant.findUnique({\r\n            where: { id },\r\n            include: {\r\n                user: true,\r\n                flat: {\r\n                    include: {\r\n                        building: true,\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!tenant) {\r\n            return ApiResponse.notFound('Tenant');\r\n        }\r\n\r\n        // Tenants can only view their own data\r\n        if (user.role === 'TENANT' && tenant.userId !== user.id) {\r\n            return ApiResponse.forbidden();\r\n        }\r\n\r\n        return ApiResponse.success(tenant);\r\n    } catch (error: any) {\r\n        try {\r\n            const { id } = await params;\r\n            logger.error('Fetch tenant error', error, { endpoint: '/api/tenants/[id]', tenantId: id });\r\n        } catch {\r\n            logger.error('Fetch tenant error', error, { endpoint: '/api/tenants/[id]' });\r\n        }\r\n        return ApiResponse.internalError('Failed to fetch tenant');\r\n    }\r\n}\r\n\r\nexport async function PATCH(\r\n    request: NextRequest,\r\n    { params }: { params: Promise<{ id: string }> }\r\n) {\r\n    try {\r\n        // Require authentication\r\n        const authResult = await requireAuth(request);\r\n        if (authResult.error) {\r\n            return authResult.error;\r\n        }\r\n\r\n        const user = authResult.user!;\r\n        const { id } = await params;\r\n        const body = await request.json();\r\n        const { name, email, flatId, moveInDate, moveOutDate, securityDeposit, photo, identityDocument, identityType } = body;\r\n\r\n        // Get current tenant to check flat changes\r\n        const currentTenant = await prisma.tenant.findUnique({\r\n            where: { id },\r\n            include: { user: true },\r\n        });\r\n\r\n        if (!currentTenant) {\r\n            return ApiResponse.notFound('Tenant');\r\n        }\r\n\r\n        // Tenants can only update their own data (limited fields)\r\n        if (user.role === 'TENANT' && currentTenant.userId !== user.id) {\r\n            return ApiResponse.forbidden();\r\n        }\r\n\r\n        // Only ADMIN/MANAGER can change flat assignments\r\n        if (flatId !== undefined && !['ADMIN', 'MANAGER'].includes(user.role)) {\r\n            return ApiResponse.forbidden('Only admins and managers can change flat assignments');\r\n        }\r\n\r\n        // Update user information\r\n        await prisma.user.update({\r\n            where: { id: currentTenant.userId },\r\n            data: {\r\n                name: name || currentTenant.user.name,\r\n                email: email || currentTenant.user.email,\r\n            },\r\n        });\r\n\r\n        // Use transaction for atomicity\r\n        const updatedTenant = await prisma.$transaction(async (tx) => {\r\n            // Handle move-out logic\r\n            if (moveOutDate && !currentTenant.moveOutDate) {\r\n                // Tenant is moving out - free up their flat\r\n                if (currentTenant.flatId) {\r\n                    await tx.flat.update({\r\n                        where: { id: currentTenant.flatId },\r\n                        data: { isOccupied: false },\r\n                    });\r\n                }\r\n            }\r\n\r\n            // Handle flat assignment changes (only if not moving out)\r\n            if (!moveOutDate) {\r\n                // Normalize flatId - treat empty string as null\r\n                const normalizedFlatId = flatId && flatId.trim() !== '' ? flatId : null;\r\n                const currentFlatIdNormalized = currentTenant.flatId || null;\r\n\r\n                if (currentFlatIdNormalized && currentFlatIdNormalized !== normalizedFlatId) {\r\n                    // Mark old flat as unoccupied\r\n                    await tx.flat.update({\r\n                        where: { id: currentFlatIdNormalized },\r\n                        data: { isOccupied: false },\r\n                    });\r\n                }\r\n\r\n                if (normalizedFlatId && normalizedFlatId !== currentFlatIdNormalized) {\r\n                    // Verify new flat exists and is not occupied\r\n                    const newFlat = await tx.flat.findUnique({ where: { id: normalizedFlatId } });\r\n                    if (!newFlat) {\r\n                        throw new Error('Flat not found');\r\n                    }\r\n                    if (newFlat.isOccupied) {\r\n                        throw new Error('Flat is already occupied');\r\n                    }\r\n                    // Mark new flat as occupied\r\n                    await tx.flat.update({\r\n                        where: { id: normalizedFlatId },\r\n                        data: { isOccupied: true },\r\n                    });\r\n                }\r\n            }\r\n\r\n            // Update user information\r\n            if (name || email) {\r\n                await tx.user.update({\r\n                    where: { id: currentTenant.userId },\r\n                    data: {\r\n                        ...(name && { name }),\r\n                        ...(email && { email }),\r\n                    },\r\n                });\r\n            }\r\n\r\n            // Update tenant\r\n            const updateData: any = {\r\n                moveInDate: moveInDate ? new Date(moveInDate) : currentTenant.moveInDate,\r\n                securityDeposit: securityDeposit !== undefined ? parseFloat(String(securityDeposit)) : currentTenant.securityDeposit,\r\n                photo: photo !== undefined ? photo : currentTenant.photo,\r\n                identityDocument: identityDocument !== undefined ? identityDocument : currentTenant.identityDocument,\r\n                identityType: identityType !== undefined ? identityType : currentTenant.identityType,\r\n            };\r\n\r\n            // Handle moveOutDate\r\n            if (moveOutDate !== undefined) {\r\n                updateData.moveOutDate = moveOutDate ? new Date(moveOutDate) : null;\r\n            }\r\n\r\n            // Handle flatId (only if not moving out)\r\n            if (!moveOutDate && flatId !== undefined) {\r\n                const normalizedFlatId = flatId && flatId.trim() !== '' ? flatId : null;\r\n                updateData.flatId = normalizedFlatId;\r\n            }\r\n\r\n            return await tx.tenant.update({\r\n                where: { id },\r\n                data: updateData,\r\n                include: {\r\n                    user: true,\r\n                    flat: {\r\n                        include: {\r\n                            building: true,\r\n                        },\r\n                    },\r\n                },\r\n            });\r\n        });\r\n\r\n        logger.info('Tenant updated', { tenantId: id, userId: user.id });\r\n        return ApiResponse.success(updatedTenant, 'Tenant updated successfully');\r\n    } catch (error: any) {\r\n        try {\r\n            const { id } = await params;\r\n            logger.error('Tenant update error', error, { endpoint: '/api/tenants/[id]', tenantId: id });\r\n        } catch {\r\n            logger.error('Tenant update error', error, { endpoint: '/api/tenants/[id]' });\r\n        }\r\n        if (error.message === 'Flat not found' || error.message === 'Flat is already occupied') {\r\n            return ApiResponse.error(error.message, 400);\r\n        }\r\n        return ApiResponse.internalError('Failed to update tenant');\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}}]
}