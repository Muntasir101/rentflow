{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/auth.ts"],"sourcesContent":["import { SignJWT, jwtVerify } from 'jose';\r\nimport { cookies } from 'next/headers';\r\nimport { NextRequest, NextResponse } from 'next/server';\r\n\r\n// Get JWT secret from environment variable (lazy loading)\r\nconst getSecretKey = () => {\r\n    const secret = process.env.JWT_SECRET;\r\n    if (!secret) {\r\n        // During build time, allow missing secret\r\n        if (process.env.NODE_ENV === 'production' && typeof window === 'undefined' && process.env.NEXT_PHASE !== 'phase-production-build') {\r\n            throw new Error('JWT_SECRET must be set in production environment');\r\n        }\r\n        // Fallback for development and build time\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            console.warn('⚠️  JWT_SECRET not set, using default. This is unsafe for production!');\r\n        }\r\n        return 'dev-secret-key-change-in-production';\r\n    }\r\n    return secret;\r\n};\r\n\r\nconst getKey = () => {\r\n    const secretKey = getSecretKey();\r\n    return new TextEncoder().encode(secretKey);\r\n};\r\n\r\nexport async function encrypt(payload: any) {\r\n    const key = getKey();\r\n    return await new SignJWT(payload)\r\n        .setProtectedHeader({ alg: 'HS256' })\r\n        .setIssuedAt()\r\n        .setExpirationTime('24h')\r\n        .sign(key);\r\n}\r\n\r\nexport async function decrypt(input: string): Promise<any> {\r\n    const key = getKey();\r\n    const { payload } = await jwtVerify(input, key, {\r\n        algorithms: ['HS256'],\r\n    });\r\n    return payload;\r\n}\r\n\r\nexport async function getSession() {\r\n    const cookieStore = await cookies();\r\n    const session = cookieStore.get('session')?.value;\r\n    if (!session) return null;\r\n    return await decrypt(session);\r\n}\r\n\r\nexport async function updateSession(request: NextRequest) {\r\n    const session = request.cookies.get('session')?.value;\r\n    if (!session) return;\r\n\r\n    // Refresh the session so it doesn't expire\r\n    const parsed = await decrypt(session);\r\n    parsed.expires = new Date(Date.now() + 24 * 60 * 60 * 1000);\r\n    const res = NextResponse.next();\r\n    res.cookies.set({\r\n        name: 'session',\r\n        value: await encrypt(parsed),\r\n        httpOnly: true,\r\n        expires: parsed.expires,\r\n    });\r\n    return res;\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;AAEA,0DAA0D;AAC1D,MAAM,eAAe;IACjB,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU;IACrC,IAAI,CAAC,QAAQ;QACT,0CAA0C;QAC1C;;QAGA,0CAA0C;QAC1C,wCAA2C;YACvC,QAAQ,IAAI,CAAC;QACjB;QACA,OAAO;IACX;IACA,OAAO;AACX;AAEA,MAAM,SAAS;IACX,MAAM,YAAY;IAClB,OAAO,IAAI,cAAc,MAAM,CAAC;AACpC;AAEO,eAAe,QAAQ,OAAY;IACtC,MAAM,MAAM;IACZ,OAAO,MAAM,IAAI,wKAAO,CAAC,SACpB,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,WAAW,GACX,iBAAiB,CAAC,OAClB,IAAI,CAAC;AACd;AAEO,eAAe,QAAQ,KAAa;IACvC,MAAM,MAAM;IACZ,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,IAAA,4KAAS,EAAC,OAAO,KAAK;QAC5C,YAAY;YAAC;SAAQ;IACzB;IACA,OAAO;AACX;AAEO,eAAe;IAClB,MAAM,cAAc,MAAM,IAAA,sLAAO;IACjC,MAAM,UAAU,YAAY,GAAG,CAAC,YAAY;IAC5C,IAAI,CAAC,SAAS,OAAO;IACrB,OAAO,MAAM,QAAQ;AACzB;AAEO,eAAe,cAAc,OAAoB;IACpD,MAAM,UAAU,QAAQ,OAAO,CAAC,GAAG,CAAC,YAAY;IAChD,IAAI,CAAC,SAAS;IAEd,2CAA2C;IAC3C,MAAM,SAAS,MAAM,QAAQ;IAC7B,OAAO,OAAO,GAAG,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK;IACtD,MAAM,MAAM,gMAAY,CAAC,IAAI;IAC7B,IAAI,OAAO,CAAC,GAAG,CAAC;QACZ,MAAM;QACN,OAAO,MAAM,QAAQ;QACrB,UAAU;QACV,SAAS,OAAO,OAAO;IAC3B;IACA,OAAO;AACX"}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/middleware.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\r\nimport type { NextRequest } from 'next/server';\r\nimport { updateSession } from '@/lib/auth';\r\n\r\nexport async function middleware(request: NextRequest) {\r\n    const session = request.cookies.get('session')?.value;\r\n\r\n    if (request.nextUrl.pathname.startsWith('/dashboard')) {\r\n        if (!session) {\r\n            return NextResponse.redirect(new URL('/login', request.url));\r\n        }\r\n    }\r\n\r\n    if (request.nextUrl.pathname === '/login') {\r\n        if (session) {\r\n            return NextResponse.redirect(new URL('/dashboard', request.url));\r\n        }\r\n    }\r\n\r\n    return await updateSession(request);\r\n}\r\n\r\nexport const config = {\r\n    matcher: ['/dashboard/:path*', '/login'],\r\n};\r\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAEA;;;AAEO,eAAe,WAAW,OAAoB;IACjD,MAAM,UAAU,QAAQ,OAAO,CAAC,GAAG,CAAC,YAAY;IAEhD,IAAI,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,eAAe;QACnD,IAAI,CAAC,SAAS;YACV,OAAO,gMAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,UAAU,QAAQ,GAAG;QAC9D;IACJ;IAEA,IAAI,QAAQ,OAAO,CAAC,QAAQ,KAAK,UAAU;QACvC,IAAI,SAAS;YACT,OAAO,gMAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,cAAc,QAAQ,GAAG;QAClE;IACJ;IAEA,OAAO,MAAM,IAAA,oIAAa,EAAC;AAC/B;AAEO,MAAM,SAAS;IAClB,SAAS;QAAC;QAAqB;KAAS;AAC5C"}}]
}